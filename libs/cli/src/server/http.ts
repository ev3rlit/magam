import * as http from 'http';
import * as path from 'path';
import * as fs from 'fs';
import glob from 'fast-glob';
import { transpile } from '../core/transpiler';
import { execute } from '../core/executor';
import { ChatHandler } from '../chat/handler';
import type { ChatPermissionMode, ProviderId, SendChatRequest, StopChatRequest } from '@magam/shared';

const DEFAULT_PORT = 3002;

export interface HttpServerConfig {
  targetDir: string;
  port?: number;
}

export interface HttpServerResult {
  port: number;
  close: () => Promise<void>;
}

/**
 * File tree node structure for folder tree view
 */
export interface FileTreeNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  children?: FileTreeNode[];
}

export async function startHttpServer(config: HttpServerConfig): Promise<HttpServerResult> {
  const port = config.port ?? (parseInt(process.env.MAGAM_HTTP_PORT || '') || DEFAULT_PORT);
  const chatHandler = new ChatHandler({ targetDir: config.targetDir });

  const server = http.createServer(async (req, res) => {
    // CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
      res.writeHead(204);
      res.end();
      return;
    }

    const url = new URL(req.url!, `http://localhost:${port}`);
    const sessionIdMatch = url.pathname.match(/^\/chat\/sessions\/([^/]+)$/);
    const sessionMessagesMatch = url.pathname.match(/^\/chat\/sessions\/([^/]+)\/messages$/);
    const groupIdMatch = url.pathname.match(/^\/chat\/groups\/([^/]+)$/);

    try {
      if (req.method === 'POST' && url.pathname === '/render') {
        await handleRender(req, res, config.targetDir);
      } else if (req.method === 'GET' && url.pathname === '/files') {
        await handleFiles(req, res, config.targetDir);
      } else if (req.method === 'GET' && url.pathname === '/file-tree') {
        await handleFileTree(req, res, config.targetDir);
      } else if (req.method === 'GET' && url.pathname === '/chat/providers') {
        await handleChatProviders(res, chatHandler);
      } else if (req.method === 'GET' && url.pathname === '/chat/sessions') {
        await handleChatSessionsList(url, res, chatHandler);
      } else if (req.method === 'POST' && url.pathname === '/chat/sessions') {
        await handleChatSessionsCreate(req, res, chatHandler);
      } else if (req.method === 'GET' && sessionIdMatch) {
        await handleChatSessionGet(res, chatHandler, decodeURIComponent(sessionIdMatch[1]));
      } else if (req.method === 'PATCH' && sessionIdMatch) {
        await handleChatSessionPatch(req, res, chatHandler, decodeURIComponent(sessionIdMatch[1]));
      } else if (req.method === 'DELETE' && sessionIdMatch) {
        await handleChatSessionDelete(res, chatHandler, decodeURIComponent(sessionIdMatch[1]));
      } else if (req.method === 'GET' && sessionMessagesMatch) {
        await handleChatSessionMessages(url, res, chatHandler, decodeURIComponent(sessionMessagesMatch[1]));
      } else if (req.method === 'GET' && url.pathname === '/chat/groups') {
        await handleChatGroupsList(res, chatHandler);
      } else if (req.method === 'POST' && url.pathname === '/chat/groups') {
        await handleChatGroupsCreate(req, res, chatHandler);
      } else if (req.method === 'PATCH' && groupIdMatch) {
        await handleChatGroupPatch(req, res, chatHandler, decodeURIComponent(groupIdMatch[1]));
      } else if (req.method === 'DELETE' && groupIdMatch) {
        await handleChatGroupDelete(res, chatHandler, decodeURIComponent(groupIdMatch[1]));
      } else if (req.method === 'POST' && url.pathname === '/chat/send') {
        await handleChatSend(req, res, chatHandler);
      } else if (req.method === 'POST' && url.pathname === '/chat/stop') {
        await handleChatStop(req, res, chatHandler);
      } else if (req.method === 'GET' && url.pathname === '/health') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: 'ok', targetDir: config.targetDir }));
      } else {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not found' }));
      }
    } catch (error: any) {
      console.error('Server Error:', error);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: error.message || 'Internal Server Error',
        type: 'SERVER_ERROR',
        details: error.stack
      }));
    }
  });

  return new Promise((resolve, reject) => {
    server.listen(port, () => {
      console.log(`HTTP render server listening on port ${port}`);
      resolve({
        port,
        close: () => new Promise((r) => server.close(() => r()))
      });
    });

    server.on('error', (err) => {
      reject(err);
    });
  });
}

async function handleRender(req: http.IncomingMessage, res: http.ServerResponse, targetDir: string) {
  const body = await parseBody(req);
  if (!body || !body.filePath) {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Missing filePath in body', type: 'VALIDATION_ERROR' }));
    return;
  }

  const absolutePath = path.resolve(targetDir, body.filePath);
  if (!fs.existsSync(absolutePath)) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: `File not found: ${body.filePath}`, type: 'FILE_NOT_FOUND' }));
    return;
  }

  try {
    const transpiled = await transpile(absolutePath);

    const result = await execute(transpiled);

    if (result.isOk()) {
      const graph = result.value;

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ graph }));
    } else {
      console.error('[HttpServer] Execution failed:', result.error);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        error: result.error.message,
        type: result.error.type || 'EXECUTION_ERROR',
        details: result.error.originalError
      }));
    }
  } catch (error: any) {
    console.error('Render Error:', error);
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      error: error.message,
      type: 'RENDER_ERROR',
      details: error.stack
    }));
  }
}

async function handleFiles(req: http.IncomingMessage, res: http.ServerResponse, targetDir: string) {
  try {
    const files = await glob('**/*.tsx', { cwd: targetDir });
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ files }));
  } catch (error: any) {
    console.error('Files Error:', error);
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      error: error.message,
      type: 'FILES_ERROR'
    }));
  }
}


interface FileEntry {
  path: string;
  type: 'file' | 'directory';
}

/**
 * Build a tree structure from a flat list of file entries
 */
function buildFileTree(entries: FileEntry[], rootName: string = 'root'): FileTreeNode {
  const root: FileTreeNode = {
    name: rootName,
    path: '',
    type: 'directory',
    children: []
  };

  for (const entry of entries) {
    const parts = entry.path.split('/');
    let current = root;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;
      const currentPath = parts.slice(0, i + 1).join('/');

      // Find existing child or create new one
      let child = current.children?.find(c => c.name === part);

      if (!child) {
        const type = isLast ? entry.type : 'directory';
        child = {
          name: part,
          path: currentPath,
          type: type,
          children: type === 'directory' ? [] : undefined
        };
        current.children?.push(child);
      }

      if (child.type === 'directory') {
        current = child;
      }
    }
  }

  // Sort children: directories first, then files, both alphabetically
  const sortChildren = (node: FileTreeNode) => {
    if (node.children) {
      node.children.sort((a, b) => {
        if (a.type !== b.type) {
          return a.type === 'directory' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });
      node.children.forEach(sortChildren);
    }
  };
  sortChildren(root);

  return root;
}

async function handleFileTree(req: http.IncomingMessage, res: http.ServerResponse, targetDir: string) {
  try {
    const rawPaths = await glob(['**/*.tsx', '**/'], {
      cwd: targetDir,
      onlyFiles: false,
      markDirectories: true,
      ignore: ['**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**']
    });

    const entries: FileEntry[] = rawPaths.map((p: string) => {
      const isDirectory = p.endsWith('/');
      return {
        path: isDirectory ? p.slice(0, -1) : p,
        type: isDirectory ? 'directory' : 'file'
      };
    });

    const tree = buildFileTree(entries, path.basename(targetDir));
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ tree }));
  } catch (error: any) {
    console.error('FileTree Error:', error);
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      error: error.message,
      type: 'FILE_TREE_ERROR'
    }));
  }
}

async function handleChatProviders(res: http.ServerResponse, chatHandler: ChatHandler) {
  const providers = await chatHandler.getProviders();
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ providers }));
}

async function handleChatSessionsList(url: URL, res: http.ServerResponse, chatHandler: ChatHandler) {
  const limit = Number(url.searchParams.get('limit') || '50');
  const sessions = await chatHandler.listSessions({
    groupId: url.searchParams.get('groupId') || undefined,
    providerId: normalizeProviderId(url.searchParams.get('providerId')),
    q: url.searchParams.get('q') || undefined,
    limit: Number.isFinite(limit) ? limit : 50,
  });

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ sessions }));
}

async function handleChatSessionsCreate(req: http.IncomingMessage, res: http.ServerResponse, chatHandler: ChatHandler) {
  const body = await parseBody(req);
  const providerId = normalizeProviderId(body.providerId);
  if (!providerId) {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'providerId is required', type: 'VALIDATION_ERROR' }));
    return;
  }

  const session = await chatHandler.createSession({
    title: typeof body.title === 'string' ? body.title : undefined,
    providerId,
    groupId: body.groupId ?? null,
  });

  res.writeHead(201, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ session }));
}

async function handleChatSessionGet(res: http.ServerResponse, chatHandler: ChatHandler, sessionId: string) {
  const session = await chatHandler.getSession(sessionId);
  if (!session) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Session not found', type: 'NOT_FOUND' }));
    return;
  }

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ session }));
}

async function handleChatSessionPatch(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  chatHandler: ChatHandler,
  sessionId: string,
) {
  const body = await parseBody(req);
  const before = await chatHandler.getSession(sessionId);
  if (!before) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Session not found', type: 'NOT_FOUND' }));
    return;
  }

  const nextProviderId = normalizeProviderId(body.providerId);

  const session = await chatHandler.updateSession(sessionId, {
    title: typeof body.title === 'string' ? body.title : undefined,
    providerId: nextProviderId,
    groupId: 'groupId' in body ? body.groupId : undefined,
  });

  if (nextProviderId && nextProviderId !== before.providerId) {
    await chatHandler.appendSystemMessage(
      sessionId,
      `Provider switched from ${before.providerId} to ${nextProviderId}`,
      { type: 'provider_switched', from: before.providerId, to: nextProviderId },
    );
  }

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ session }));
}

async function handleChatSessionDelete(res: http.ServerResponse, chatHandler: ChatHandler, sessionId: string) {
  const deleted = await chatHandler.deleteSession(sessionId);
  if (!deleted) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Session not found', type: 'NOT_FOUND' }));
    return;
  }

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ deleted: true }));
}

async function handleChatSessionMessages(url: URL, res: http.ServerResponse, chatHandler: ChatHandler, sessionId: string) {
  const limit = Number(url.searchParams.get('limit') || '50');
  const result = await chatHandler.listMessages(
    sessionId,
    url.searchParams.get('cursor') || undefined,
    Number.isFinite(limit) ? limit : 50,
  );

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(result));
}

async function handleChatGroupsList(res: http.ServerResponse, chatHandler: ChatHandler) {
  const groups = await chatHandler.listGroups();
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ groups }));
}

async function handleChatGroupsCreate(req: http.IncomingMessage, res: http.ServerResponse, chatHandler: ChatHandler) {
  const body = await parseBody(req);
  if (!body?.name || typeof body.name !== 'string') {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'name is required', type: 'VALIDATION_ERROR' }));
    return;
  }

  const group = await chatHandler.createGroup({
    name: body.name,
    color: typeof body.color === 'string' ? body.color : undefined,
    sortOrder: typeof body.sortOrder === 'number' ? body.sortOrder : undefined,
  });

  res.writeHead(201, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ group }));
}

async function handleChatGroupPatch(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  chatHandler: ChatHandler,
  groupId: string,
) {
  const body = await parseBody(req);
  const group = await chatHandler.updateGroup(groupId, {
    name: typeof body.name === 'string' ? body.name : undefined,
    color: body.color === null || typeof body.color === 'string' ? body.color : undefined,
    sortOrder: typeof body.sortOrder === 'number' ? body.sortOrder : undefined,
  });

  if (!group) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Group not found', type: 'NOT_FOUND' }));
    return;
  }

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ group }));
}

async function handleChatGroupDelete(res: http.ServerResponse, chatHandler: ChatHandler, groupId: string) {
  const deleted = await chatHandler.deleteGroup(groupId);
  if (!deleted) {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Group not found', type: 'NOT_FOUND' }));
    return;
  }

  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ deleted: true, fallbackGroupId: null }));
}


function normalizePermissionMode(raw: unknown): ChatPermissionMode {
  return raw === 'interactive' ? 'interactive' : 'auto';
}

function normalizeProviderId(raw: unknown): ProviderId | undefined {
  if (raw === 'claude' || raw === 'gemini' || raw === 'codex') return raw;
  return undefined;
}

function normalizeModel(raw: unknown): string | undefined {
  if (typeof raw !== 'string') return undefined;
  const model = raw.trim();
  if (!model || model.length > MAX_MODEL_LENGTH) return undefined;
  if (!MODEL_PATTERN.test(model)) return undefined;
  return model;
}

function normalizeReasoningEffort(raw: unknown): 'low' | 'medium' | 'high' | undefined {
  if (typeof raw !== 'string') return undefined;
  const normalized = raw.trim().toLowerCase();
  if (normalized === 'low' || normalized === 'medium' || normalized === 'high') {
    return normalized;
  }
  return undefined;
}

const MAX_FILE_MENTIONS = 10;
const MAX_NODE_MENTIONS = 20;
const MAX_PATH_LENGTH = 512;
const MAX_NODE_FIELD_LENGTH = 2000;
const MAX_MODEL_LENGTH = 120;
const MODEL_PATTERN = /^[a-zA-Z0-9][a-zA-Z0-9._:/-]*$/;

function normalizeFileMentions(raw: unknown): SendChatRequest['fileMentions'] {
  if (!Array.isArray(raw)) return undefined;

  const mentions: NonNullable<SendChatRequest['fileMentions']> = [];
  for (const entry of raw.slice(0, MAX_FILE_MENTIONS)) {
    const mentionPath =
      typeof entry === 'string' ? entry.trim() : typeof entry?.path === 'string' ? entry.path.trim() : '';

    if (!mentionPath || mentionPath.length > MAX_PATH_LENGTH) {
      continue;
    }

    mentions.push({ path: mentionPath });
  }

  return mentions.length > 0 ? mentions : undefined;
}

function normalizeNodeMentions(raw: unknown): SendChatRequest['nodeMentions'] {
  if (!Array.isArray(raw)) return undefined;

  const mentions: NonNullable<SendChatRequest['nodeMentions']> = [];

  for (const entry of raw.slice(0, MAX_NODE_MENTIONS)) {
    if (!entry || typeof entry !== 'object') continue;

    const id = typeof entry.id === 'string' ? entry.id.trim() : '';
    if (!id || id.length > MAX_NODE_FIELD_LENGTH) continue;

    const sanitize = (value: unknown): string | undefined => {
      if (typeof value !== 'string') return undefined;
      const trimmed = value.trim();
      if (!trimmed) return undefined;
      return trimmed.slice(0, MAX_NODE_FIELD_LENGTH);
    };

    const mention = {
      id,
      type: sanitize(entry.type),
      title: sanitize(entry.title),
      summary: sanitize(entry.summary),
    };

    if (!mention.summary) continue;
    mentions.push(mention);
  }

  return mentions.length > 0 ? mentions : undefined;
}

async function handleChatSend(req: http.IncomingMessage, res: http.ServerResponse, chatHandler: ChatHandler) {
  const body = (await parseBody(req)) as Partial<SendChatRequest> & { workingDirectory?: string };

  if (body.workingDirectory) {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      error: 'workingDirectory must not be provided by client',
      type: 'VALIDATION_ERROR',
    }));
    return;
  }

  const providerId = normalizeProviderId(body.providerId);
  if (!body.message || !providerId) {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Missing message/providerId in body', type: 'VALIDATION_ERROR' }));
    return;
  }

  const normalizedEffort =
    normalizeReasoningEffort(body.reasoningEffort) ??
    normalizeReasoningEffort(body.effort) ??
    normalizeReasoningEffort(body.reasoning);

  const request: SendChatRequest = {
    message: body.message,
    providerId,
    sessionId: body.sessionId,
    currentFile: body.currentFile,
    permissionMode: normalizePermissionMode(body.permissionMode),
    model: normalizeModel(body.model),
    ...(normalizedEffort ? { reasoningEffort: normalizedEffort } : {}),
    fileMentions: normalizeFileMentions(body.fileMentions),
    nodeMentions: normalizeNodeMentions(body.nodeMentions),
  };

  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
  });

  try {
    for await (const chunk of chatHandler.send(request)) {
      res.write(`event: ${chunk.type === 'done' ? 'done' : chunk.type === 'error' ? 'error' : 'chunk'}\n`);
      res.write(`data: ${JSON.stringify(chunk)}\n\n`);
    }
  } catch (error: any) {
    const chunk = {
      type: 'error',
      content: error?.message || 'Chat stream failed',
      metadata: { stage: 'server-stream' },
    };
    res.write('event: error\n');
    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
  } finally {
    res.end();
  }
}

async function handleChatStop(req: http.IncomingMessage, res: http.ServerResponse, chatHandler: ChatHandler) {
  const body = (await parseBody(req)) as Partial<StopChatRequest>;
  if (!body.sessionId) {
    res.writeHead(400, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Missing sessionId in body', type: 'VALIDATION_ERROR' }));
    return;
  }

  const stopped = chatHandler.stop(body.sessionId);
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(stopped));
}

function parseBody(req: http.IncomingMessage): Promise<any> {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch (e) {
        resolve({});
      }
    });
    req.on('error', reject);
  });
}
